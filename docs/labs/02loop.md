# 实验 2：循环和执行流控制

这个实验会依赖于实验 1 中的结果，因此请确保你所使用的实验 1 的代码能够通过测试. 

!!! notes 致谢

    这个实验中用到的所有测试代码均是笔者在玩 Steam 游戏 A = B 时所写，且这个大程的主要灵感来源也是这个游戏——尽管从下一个实验开始我们就将部分地与它分道扬镳. 额外的思考题实际上也是来源于这个游戏 6-2 关卡的设计，你可以去 Steam 社区寻找答案——当然，与我们这里的要求有一点点微小的输入范围和语法差异.

## 实验准备

- 按照实验 0（环境配置指南）的要求完成 Python 环境的安装和配置；
- 完成实验 1 的代码；
- 学习关于布尔变量、`#!python if` 语句和 `#!python while` 语句的知识.

## 任务要求

本实验将要求你复用先前的模块来完成任务，因此首先打开 `problem.py`，将上一次实验的代码填充进给定的函数当中. 第一步，修改 `single_line_process` 函数，使得它额外返回一个布尔值：如果成功替换则返回 `#!python True`，如果未进行替换则返回 `#!python False`. 这一步的目的是方便接下来的修改.

接下来，我们需要实现 `main_loop` 函数，这个函数是本实验的核心. 我们要求对一系列形如 `A = B;` 的语句从左到右按顺序进行如下处理：

- 如果一个语句能够完成替换，则忽略它之后的语句，回到第一个语句重新执行；
- 如果所有语句均不能完成替换，则结束整个函数，并返回最终替换的结果.

## 执行过程

下面是一个系列语句的例子：

`B = A; C = A; AA = A; A = helloworld;`

这是我们这套“编程语言”——如果你乐意这样称呼的话——的 Hello World 代码. 它接受任意一个由 `A`、`B`、`C` 构成的字符串，然后将其变成 `helloworld`. 例如如果输入字符串 `ABC`，执行流程如下：

- 第一步，执行 `B = A;`，得到 `AAC`，然后回头重新扫描；
- 第二步，发现 `B = A;` 不可能再被执行，尝试执行到 `C = A;`，得到 `AAA`，回头重新扫描；
- 第三步，发现 `B = A;` 和 `C = A;` 都无法替换，尝试执行 `AA = A;`，得到 `AA`，回头重新扫描；
- 第四步，同理 `B = A;` 和 `C = A;` 无法执行，尝试执行 `AA = A`，得到 `A`，再从头开始；
- 第五步，前面三条指令都不再能够被执行，最后执行 `A = helloworld;`，得到 `helloworld`，回头重新扫描；
- 最后，发现字符串不再含有 `B`、`C`、`AA` 和 `A`，返回 `helloworld` 作为结果.

## 测试方法

与之前相同. 我们会测试三个简单的系列语句，只需通过测试即可.

## 补充说明

- 你可以修改 `single_line_process` 实现中更多的东西来方便自己的处理；
- 这个系统实际上被称为转写器（transducer）. 人们在大约七十年前就已经发现，这确实是一种“编程语言”，换句话说，它是图灵完备的（Turing complete），可以实现一台理想计算机所能完成的所有操作，这是它的有趣之处.

## 附加思考题

打开 `extra_test.py`，在此之前请确保你的 `main_loop` 函数能够通过前面的测试，否则你可能遇到数不清的问题.

这里要求你编写一个用这种“编程语言”实现的程序，其作用是判断输入的字符串是否是回文串，如果是则返回字符串 `true`，否则返回 `false`. 输入的字符串保证只由 `A`、`B`、`C` 这三个字母组成.

### 测试样例

我们要求得到以下结果：

```python
main_loop("A", self.lines) == "true"
main_loop("ABBA", self.lines) == "true"
main_loop("ABCBA", self.lines) == "true"
main_loop("AABA", self.lines) == "false"
```
